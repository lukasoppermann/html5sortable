{"version":3,"file":"html5sortable.min.js","sources":["../src/data.ts","../src/filter.ts","../src/store.ts","../src/eventListener.ts","../src/attribute.ts","../src/offset.ts","../src/debounce.ts","../src/getIndex.ts","../src/isInDom.ts","../src/insertHtmlElements.ts","../src/serialize.ts","../src/makePlaceholder.ts","../src/elementHeight.ts","../src/elementWidth.ts","../src/getHandles.ts","../src/getEventTarget.ts","../src/setDragImage.ts","../src/isConnected.ts","../src/defaultConfiguration.ts","../src/html5sortable.ts","../src/hoverClass.ts","../src/throttle.ts"],"sourcesContent":["/**\n * Get or set data on element\n * @param {HTMLElement} element\n * @param {string} key\n * @param {any} value\n * @return {*}\n */\n\nfunction addData (element: HTMLElement, key: string, value?: any): HTMLElement|configuration|string|void {\n  if (value === undefined) {\n    return element && element.h5s && element.h5s.data && element.h5s.data[key]\n  } else {\n    element.h5s = element.h5s || {}\n    element.h5s.data = element.h5s.data || {}\n    element.h5s.data[key] = value\n  }\n}\n/**\n * Remove data from element\n * @param {HTMLElement} element\n */\nfunction removeData (element: HTMLElement) {\n  if (element.h5s) {\n    delete element.h5s.data\n  }\n}\n\nexport { addData, removeData }\n","/* eslint-env browser */\n/**\n * Filter only wanted nodes\n * @param {NodeList|HTMLCollection|Array} nodes\n * @param {String} selector\n * @returns {Array}\n */\nexport default (nodes: NodeList|HTMLCollection|Array<HTMLElement>, selector: string): Array<HTMLElement> => {\n  if (!(nodes instanceof NodeList || nodes instanceof HTMLCollection || nodes instanceof Array)) {\n    throw new Error('You must provide a nodeList/HTMLCollection/Array of elements to be filtered.')\n  }\n  if (typeof selector !== 'string') {\n    return Array.from(nodes)\n  }\n\n  return Array.from(nodes).filter((item) => item.nodeType === 1 && item.matches(selector))\n}\n","/* eslint-env browser */\n/* eslint-disable no-use-before-define */\nexport const stores: Map<HTMLElement, Store> = new Map()\n/* eslint-enable no-use-before-define */\n/**\n * Stores data & configurations per Sortable\n * @param {Object} config\n */\nexport class Store implements Store {\n  private _config: Map<string, any> = new Map() // eslint-disable-line no-undef\n  private _placeholder?: HTMLElement = undefined // eslint-disable-line no-undef\n  private _data: Map<string, any> = new Map() // eslint-disable-line no-undef\n  /**\n   * set the configuration of a class instance\n   * @method config\n   * @param {object} config object of configurations\n   */\n  set config (config: configuration) {\n    if (typeof config !== 'object') {\n      throw new Error('You must provide a valid configuration object to the config setter.')\n    }\n    // combine config with default\n    const mergedConfig = Object.assign({}, config)\n    // add config to map\n    this._config = new Map(Object.entries(mergedConfig))\n  }\n  /**\n   * get the configuration map of a class instance\n   * @method config\n   * @return {object}\n   */\n\n  get config (): configuration {\n    // transform Map to object\n    const config = {}\n    this._config.forEach((value, key) => {\n      config[key] = value\n    })\n    // return object\n    return config\n  }\n\n  /**\n   * set individual configuration of a class instance\n   * @method setConfig\n   * @param  key valid configuration key\n   * @param  value any value\n   * @return void\n   */\n  setConfig (key: string, value: any): void {\n    if (!this._config.has(key)) {\n      throw new Error(`Trying to set invalid configuration item: ${key}`)\n    }\n    // set config\n    this._config.set(key, value)\n  }\n\n  /**\n   * get an individual configuration of a class instance\n   * @method getConfig\n   * @param  key valid configuration key\n   * @return any configuration value\n   */\n  getConfig (key: string): any {\n    if (!this._config.has(key)) {\n      throw new Error(`Invalid configuration item requested: ${key}`)\n    }\n    return this._config.get(key)\n  }\n\n  /**\n   * get the placeholder for a class instance\n   * @method placeholder\n   * @return {HTMLElement|null}\n   */\n  get placeholder (): HTMLElement {\n    return this._placeholder\n  }\n\n  /**\n   * set the placeholder for a class instance\n   * @method placeholder\n   * @param {HTMLElement} placeholder\n   * @return {void}\n   */\n  set placeholder (placeholder: HTMLElement): void {\n    if (!(placeholder instanceof HTMLElement) && placeholder !== null) {\n      throw new Error('A placeholder must be an html element or null.')\n    }\n    this._placeholder = placeholder\n  }\n\n  /**\n   * set an data entry\n   * @method setData\n   * @param {string} key\n   * @param {any} value\n   * @return {void}\n   */\n  setData (key: string, value: Function): void {\n    if (typeof key !== 'string') {\n      throw new Error('The key must be a string.')\n    }\n    this._data.set(key, value)\n  }\n\n  /**\n   * get an data entry\n   * @method getData\n   * @param {string} key an existing key\n   * @return {any}\n   */\n  getData (key: string): any {\n    if (typeof key !== 'string') {\n      throw new Error('The key must be a string.')\n    }\n    return this._data.get(key)\n  }\n\n  /**\n   * delete an data entry\n   * @method deleteData\n   * @param {string} key an existing key\n   * @return {boolean}\n   */\n  deleteData (key: string): boolean {\n    if (typeof key !== 'string') {\n      throw new Error('The key must be a string.')\n    }\n    return this._data.delete(key)\n  }\n}\n/**\n * @param {HTMLElement} sortableElement\n * @returns {Class: Store}\n */\nexport default (sortableElement: HTMLElement): Store => {\n  // if sortableElement is wrong type\n  if (!(sortableElement instanceof HTMLElement)) {\n    throw new Error('Please provide a sortable to the store function.')\n  }\n  // create new instance if not avilable\n  if (!stores.has(sortableElement)) {\n    stores.set(sortableElement, new Store())\n  }\n  // return instance\n  return stores.get(sortableElement)\n}\n","import store from './store'\n/**\n * @param {Array|HTMLElement} element\n * @param {Function} callback\n * @param {string} event\n */\nfunction addEventListener (element: Array<HTMLElement>|HTMLElement, eventName:string, callback: () => void) {\n  if (element instanceof Array) {\n    for (let i = 0; i < element.length; ++i) {\n      addEventListener(element[i], eventName, callback)\n    }\n    return\n  }\n  element.addEventListener(eventName, callback)\n  store(element).setData(`event${eventName}`, callback)\n}\n/**\n * @param {Array<HTMLElement>|HTMLElement} element\n * @param {string} eventName\n */\nfunction removeEventListener (element: Array<HTMLElement>|HTMLElement, eventName: string) {\n  if (element instanceof Array) {\n    for (let i = 0; i < element.length; ++i) {\n      removeEventListener(element[i], eventName)\n    }\n    return\n  }\n  element.removeEventListener(eventName, store(element).getData(`event${eventName}`))\n  store(element).deleteData(`event${eventName}`)\n}\n\nexport { addEventListener, removeEventListener }\n","/**\n * @param {Array<HTMLElement>|HTMLElement} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction addAttribute (element: Array<HTMLElement>|HTMLElement, attribute:string, value:string) {\n  if (element instanceof Array) {\n    for (let i = 0; i < element.length; ++i) {\n      addAttribute(element[i], attribute, value)\n    }\n    return\n  }\n  element.setAttribute(attribute, value)\n}\n/**\n * @param {Array|HTMLElement} element\n * @param {string} attribute\n */\nfunction removeAttribute (element: Array<HTMLElement>|HTMLElement, attribute:string) {\n  if (element instanceof Array) {\n    for (let i = 0; i < element.length; ++i) {\n      removeAttribute(element[i], attribute)\n    }\n    return\n  }\n  element.removeAttribute(attribute)\n}\n\nexport { addAttribute, removeAttribute }\n","/**\n * @param {HTMLElement} element\n * @returns {Object}\n */\nexport default (element: HTMLElement): offsetObject => {\n  if (!element.parentElement || element.getClientRects().length === 0) {\n    throw new Error('target element must be part of the dom')\n  }\n\n  const rect = element.getClientRects()[0]\n  return {\n    left: rect.left + window.pageXOffset,\n    right: rect.right + window.pageXOffset,\n    top: rect.top + window.pageYOffset,\n    bottom: rect.bottom + window.pageYOffset\n  }\n}\n","/**\n * Creates and returns a new debounced version of the passed function which will postpone its execution until after wait milliseconds have elapsed\n * @param {Function} func to debounce\n * @param {number} time to wait before calling function with latest arguments, 0 - no debounce\n * @returns {function} - debounced function\n */\nexport default (func: Function, wait: number = 0): Function => {\n  let timeout\n  return (...args) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => {\n      func(...args)\n    }, wait)\n  }\n}\n","/* eslint-env browser */\n/**\n * Get position of the element relatively to its sibling elements\n * @param {HTMLElement} element\n * @returns {number}\n */\nexport default (element: HTMLElement, elementList: HTMLCollection | NodeList | Array<HTMLElement>): number => {\n  if (!(element instanceof HTMLElement) || !(elementList instanceof NodeList || elementList instanceof HTMLCollection || elementList instanceof Array)) {\n    throw new Error('You must provide an element and a list of elements.')\n  }\n\n  return Array.from(elementList).indexOf(element)\n}\n","/* eslint-env browser */\n/**\n * Test whether element is in DOM\n * @param {HTMLElement} element\n * @returns {boolean}\n */\nexport default (element: HTMLElement): boolean => {\n  if (!(element instanceof HTMLElement)) {\n    throw new Error('Element is not a node element.')\n  }\n\n  return element.parentNode !== null\n}\n","/* eslint-env browser */\n/**\n * Insert node before or after target\n * @param {HTMLElement} referenceNode - reference element\n * @param {HTMLElement} newElement - element to be inserted\n * @param {String} position - insert before or after reference element\n */\nconst insertNode = (referenceNode: HTMLElement, newElement: HTMLElement, position: String) => {\n  if (!(referenceNode instanceof HTMLElement) || !(referenceNode.parentElement instanceof HTMLElement)) {\n    throw new Error('target and element must be a node')\n  }\n  referenceNode.parentElement.insertBefore(\n    newElement,\n    (position === 'before' ? referenceNode : referenceNode.nextElementSibling)\n  )\n}\n/**\n * Insert before target\n * @param {HTMLElement} target\n * @param {HTMLElement} element\n */\nconst insertBefore = (target: HTMLElement, element: HTMLElement) => insertNode(target, element, 'before')\n/**\n * Insert after target\n * @param {HTMLElement} target\n * @param {HTMLElement} element\n */\nconst insertAfter = (target: HTMLElement, element: HTMLElement) => insertNode(target, element, 'after')\n\nexport { insertBefore, insertAfter }\n","/* eslint-env browser */\nimport { addData } from './data' // yuk, data really needs to be refactored\nimport filter from './filter'\nimport getIndex from './getIndex'\n/**\n * Filter only wanted nodes\n * @param {HTMLElement} sortableContainer\n * @param {Function} customSerializer\n * @returns {Array}\n */\nexport default (sortableContainer: HTMLElement, customItemSerializer: Function = (serializedItem: serializedItem, sortableContainer: HTMLElement) => serializedItem, customContainerSerializer: Function = (serializedContainer: object) => serializedContainer): object => {\n  // check for valid sortableContainer\n  if (!(sortableContainer instanceof HTMLElement) || !sortableContainer.isSortable === true) {\n    throw new Error('You need to provide a sortableContainer to be serialized.')\n  }\n  // check for valid serializers\n  if (typeof customItemSerializer !== 'function' || typeof customContainerSerializer !== 'function') {\n    throw new Error('You need to provide a valid serializer for items and the container.')\n  }\n  // get options\n  const options = addData(sortableContainer, 'opts')\n\n  const item: string|undefined = options.items\n\n  // serialize container\n  const items = filter(sortableContainer.children, item)\n  const serializedItems: serializedItem[] = items.map((item) => {\n    return {\n      parent: sortableContainer,\n      node: item,\n      html: item.outerHTML,\n      index: getIndex(item, items)\n    }\n  })\n  // serialize container\n  const container = {\n    node: sortableContainer,\n    itemCount: serializedItems.length\n  }\n\n  return {\n    container: customContainerSerializer(container),\n    items: serializedItems.map((item: object) => customItemSerializer(item, sortableContainer))\n  }\n}\n","/* eslint-env browser */\n/**\n * create a placeholder element\n * @param {HTMLElement} sortableElement a single sortable\n * @param {string|undefined} placeholder a string representing an html element\n * @param {string} placeholderClasses a string representing the classes that should be added to the placeholder\n */\nexport default (sortableElement: HTMLElement, placeholder?: HTMLElement, placeholderClass: string = 'sortable-placeholder') => {\n  if (!(sortableElement instanceof HTMLElement)) {\n    throw new Error('You must provide a valid element as a sortable.')\n  }\n  // if placeholder is not an element\n  if (!(placeholder instanceof HTMLElement) && placeholder !== undefined) {\n    throw new Error('You must provide a valid element as a placeholder or set ot to undefined.')\n  }\n  // if no placeholder element is given\n  if (placeholder === undefined) {\n    if (['UL', 'OL'].includes(sortableElement.tagName)) {\n      placeholder = document.createElement('li')\n    } else if (['TABLE', 'TBODY'].includes(sortableElement.tagName)) {\n      placeholder = document.createElement('tr')\n      // set colspan to always all rows, otherwise the item can only be dropped in first column\n      placeholder.innerHTML = '<td colspan=\"100\"></td>'\n    } else {\n      placeholder = document.createElement('div')\n    }\n  }\n  // add classes to placeholder\n  if (typeof placeholderClass === 'string') {\n    placeholder.classList.add(...placeholderClass.split(' '))\n  }\n\n  return placeholder\n}\n","/* eslint-env browser */\n/**\n * Get height of an element including padding\n * @param {HTMLElement} element an dom element\n */\nexport default (element: HTMLElement) => {\n  if (!(element instanceof HTMLElement)) {\n    throw new Error('You must provide a valid dom element')\n  }\n  // get calculated style of element\n  const style = window.getComputedStyle(element)\n  // get only height if element has box-sizing: border-box specified\n  if (style.getPropertyValue('box-sizing') === 'border-box') {\n    return parseInt(style.getPropertyValue('height'), 10)\n  }\n  // pick applicable properties, convert to int and reduce by adding\n  return ['height', 'padding-top', 'padding-bottom']\n    .map((key) => {\n      const int = parseInt(style.getPropertyValue(key), 10)\n      return isNaN(int) ? 0 : int\n    })\n    .reduce((sum, value) => sum + value)\n}\n","/* eslint-env browser */\n/**\n * Get width of an element including padding\n * @param {HTMLElement} element an dom element\n */\nexport default (element: HTMLElement) => {\n  if (!(element instanceof HTMLElement)) {\n    throw new Error('You must provide a valid dom element')\n  }\n  // get calculated style of element\n  const style = window.getComputedStyle(element)\n  // pick applicable properties, convert to int and reduce by adding\n  return ['width', 'padding-left', 'padding-right']\n    .map((key) => {\n      const int = parseInt(style.getPropertyValue(key), 10)\n      return isNaN(int) ? 0 : int\n    })\n    .reduce((sum, value) => sum + value)\n}\n","/* eslint-env browser */\n/**\n * get handle or return item\n * @param {Array<HTMLElement>} items\n * @param {string} selector\n */\n\nexport default (items: Array<HTMLElement>, selector: string): Array<HTMLElement> => {\n  if (!(items instanceof Array)) {\n    throw new Error('You must provide a Array of HTMLElements to be filtered.')\n  }\n\n  if (typeof selector !== 'string') {\n    return items\n  }\n\n  return items\n  // remove items without handle from array\n    .filter((item: HTMLElement) => {\n      return item.querySelector(selector) instanceof HTMLElement ||\n        (item.shadowRoot && item.shadowRoot.querySelector(selector) instanceof HTMLElement)\n    })\n    // replace item with handle in array\n    .map((item: HTMLElement) => {\n      return item.querySelector(selector) || (item.shadowRoot && item.shadowRoot.querySelector(selector))\n    })\n}\n","/**\n * @param {Event} event\n * @returns {HTMLElement}\n */\nexport default (event: Event): HTMLElement => {\n  return (event.composedPath && event.composedPath()[0]) || event.target\n}\n","/* eslint-env browser */\nimport offset from './offset'\nimport getEventTarget from './getEventTarget'\n/**\n * defaultDragImage returns the current item as dragged image\n * @param {HTMLElement} draggedElement - the item that the user drags\n * @param {object} elementOffset - an object with the offsets top, left, right & bottom\n * @param {Event} event - the original drag event object\n * @return {object} with element, posX and posY properties\n */\nconst defaultDragImage = (draggedElement: HTMLElement, elementOffset: offsetObject, event: DragEvent): object => {\n  return {\n    element: draggedElement,\n    posX: event.pageX - elementOffset.left,\n    posY: event.pageY - elementOffset.top\n  }\n}\n/**\n * attaches an element as the drag image to an event\n * @param {Event} event - the original drag event object\n * @param {HTMLElement} draggedElement - the item that the user drags\n * @param {Function} customDragImage - function to create a custom dragImage\n * @return void\n */\nexport default (event: DragEvent, draggedElement: HTMLElement, customDragImage: Function): void => {\n  // check if event is provided\n  if (!(event instanceof Event)) {\n    throw new Error('setDragImage requires a DragEvent as the first argument.')\n  }\n  // check if draggedElement is provided\n  if (!(draggedElement instanceof HTMLElement)) {\n    throw new Error('setDragImage requires the dragged element as the second argument.')\n  }\n  // set default function of none provided\n  if (!customDragImage) {\n    customDragImage = defaultDragImage\n  }\n  // check if setDragImage method is available\n  if (event.dataTransfer && event.dataTransfer.setDragImage) {\n    // get the elements offset\n    const elementOffset = offset(draggedElement)\n    // get the dragImage\n    const dragImage = customDragImage(draggedElement, elementOffset, event)\n    // check if custom function returns correct values\n    if (!(dragImage.element instanceof HTMLElement) || typeof dragImage.posX !== 'number' || typeof dragImage.posY !== 'number') {\n      throw new Error('The customDragImage function you provided must return and object with the properties element[string], posX[integer], posY[integer].')\n    }\n    // needs to be set for HTML5 drag & drop to work\n    event.dataTransfer.effectAllowed = 'copyMove'\n    // Firefox requires it to use the event target's id for the data\n    event.dataTransfer.setData('text/plain', getEventTarget(event).id)\n    // set the drag image on the event\n    event.dataTransfer.setDragImage(dragImage.element, dragImage.posX, dragImage.posY)\n  }\n}\n","import store from './store'\n/**\n * Check if curList accepts items from destList\n * @param {sortable} destination the container an item is move to\n * @param {sortable} origin the container an item comes from\n */\nexport default (destination: sortable, origin: sortable) => {\n  // check if valid sortable\n  if (destination.isSortable === true) {\n    const acceptFrom = store(destination).getConfig('acceptFrom')\n    // check if acceptFrom is valid\n    if (acceptFrom !== null && acceptFrom !== false && typeof acceptFrom !== 'string') {\n      throw new Error('HTML5Sortable: Wrong argument, \"acceptFrom\" must be \"null\", \"false\", or a valid selector string.')\n    }\n\n    if (acceptFrom !== null) {\n      return acceptFrom !== false && acceptFrom.split(',').filter(function (sel) {\n        return sel.length > 0 && origin.matches(sel)\n      }).length > 0\n    }\n    // drop in same list\n    if (destination === origin) {\n      return true\n    }\n    // check if lists are connected with connectWith\n    if (store(destination).getConfig('connectWith') !== undefined && store(destination).getConfig('connectWith') !== null) {\n      return store(destination).getConfig('connectWith') === store(origin).getConfig('connectWith')\n    }\n  }\n  return false\n}\n","/**\n * default configurations\n */\nexport default {\n  items: null,\n  // deprecated\n  connectWith: null,\n  // deprecated\n  disableIEFix: null,\n  acceptFrom: null,\n  copy: false,\n  placeholder: null,\n  placeholderClass: 'sortable-placeholder',\n  draggingClass: 'sortable-dragging',\n  hoverClass: false,\n  dropTargetContainerClass: false,\n  debounce: 0,\n  throttleTime: 100,\n  maxItems: 0,\n  itemSerializer: undefined,\n  containerSerializer: undefined,\n  customDragImage: null,\n  orientation: 'vertical'\n}\n","/* eslint-env browser */\n'use strict'\n\nimport { addData as data, removeData } from './data'\nimport filter from './filter'\nimport { addEventListener as on, removeEventListener as off } from './eventListener'\nimport { addAttribute as attr, removeAttribute as removeAttr } from './attribute'\nimport offset from './offset'\nimport debounce from './debounce'\nimport getIndex from './getIndex'\nimport isInDom from './isInDom'\nimport { insertBefore as before, insertAfter as after } from './insertHtmlElements'\nimport serialize from './serialize'\nimport makePlaceholder from './makePlaceholder'\nimport getElementHeight from './elementHeight'\nimport getElementWidth from './elementWidth'\nimport getHandles from './getHandles'\nimport getEventTarget from './getEventTarget'\nimport setDragImage from './setDragImage'\nimport { default as store, stores } from './store' /* eslint-disable-line */\nimport listsConnected from './isConnected'\nimport defaultConfiguration from './defaultConfiguration'\nimport enableHoverClass from './hoverClass'\n\n/*\n * variables global to the plugin\n */\nlet dragging\nlet draggingHeight\nlet draggingWidth\n\n/*\n * Keeps track of the initialy selected list, where 'dragstart' event was triggered\n * It allows us to move the data in between individual Sortable List instances\n */\n\n// Origin List - data from before any item was changed\nlet originContainer\nlet originIndex\nlet originElementIndex\nlet originItemsBeforeUpdate\n\n// Previous Sortable Container - we dispatch as sortenter event when a\n// dragged item enters a sortableContainer for the first time\nlet previousContainer\n\n// Destination List - data from before any item was changed\nlet destinationItemsBeforeUpdate\n\n/**\n * remove event handlers from items\n * @param {Array|NodeList} items\n */\nconst removeItemEvents = function (items) {\n  off(items, 'dragstart')\n  off(items, 'dragend')\n  off(items, 'dragover')\n  off(items, 'dragenter')\n  off(items, 'drop')\n  off(items, 'mouseenter')\n  off(items, 'mouseleave')\n}\n\n// Remove container events\nconst removeContainerEvents = function (originContainer, previousContainer) {\n  if (originContainer) {\n    off(originContainer, 'dragleave')\n  }\n  if (previousContainer && (previousContainer !== originContainer)) {\n    off(previousContainer, 'dragleave')\n  }\n}\n\n/**\n * getDragging returns the current element to drag or\n * a copy of the element.\n * Is Copy Active for sortable\n * @param {HTMLElement} draggedItem - the item that the user drags\n * @param {HTMLElement} sortable a single sortable\n */\nconst getDragging = function (draggedItem, sortable) {\n  let ditem = draggedItem\n  if (store(sortable).getConfig('copy') === true) {\n    ditem = draggedItem.cloneNode(true)\n    attr(ditem, 'aria-copied', 'true')\n    draggedItem.parentElement.appendChild(ditem)\n    ditem.style.display = 'none'\n    ditem.oldDisplay = draggedItem.style.display\n  }\n  return ditem\n}\n/**\n * Remove data from sortable\n * @param {HTMLElement} sortable a single sortable\n */\nconst removeSortableData = function (sortable) {\n  removeData(sortable)\n  removeAttr(sortable, 'aria-dropeffect')\n}\n/**\n * Remove data from items\n * @param {Array<HTMLElement>|HTMLElement} items\n */\nconst removeItemData = function (items) {\n  removeAttr(items, 'aria-grabbed')\n  removeAttr(items, 'aria-copied')\n  removeAttr(items, 'draggable')\n  removeAttr(items, 'role')\n}\n/**\n * find sortable from element. travels up parent element until found or null.\n * @param {HTMLElement} element a single sortable\n * @param {Event} event - the current event. We need to pass it to be able to\n * find Sortable whith shadowRoot (document fragment has no parent)\n */\nfunction findSortable (element, event) {\n  if (event.composedPath) {\n    return event.composedPath().find(el => el.isSortable)\n  }\n  while (element.isSortable !== true) {\n    element = element.parentElement\n  }\n  return element\n}\n/**\n * Dragging event is on the sortable element. finds the top child that\n * contains the element.\n * @param {HTMLElement} sortableElement a single sortable\n * @param {HTMLElement} element is that being dragged\n */\nfunction findDragElement (sortableElement, element) {\n  const options = data(sortableElement, 'opts')\n  const items = filter(sortableElement.children, options.items)\n  const itemlist = items.filter(function (ele) {\n    return ele.contains(element) || (ele.shadowRoot && ele.shadowRoot.contains(element))\n  })\n\n  return itemlist.length > 0 ? itemlist[0] : element\n}\n/**\n * Destroy the sortable\n * @param {HTMLElement} sortableElement a single sortable\n */\nconst destroySortable = function (sortableElement) {\n  const opts = data(sortableElement, 'opts') || {}\n  const items = filter(sortableElement.children, opts.items)\n  const handles = getHandles(items, opts.handle)\n  // disable adding hover class\n  enableHoverClass(sortableElement, false)\n  // remove event handlers & data from sortable\n  off(sortableElement, 'dragover')\n  off(sortableElement, 'dragenter')\n  off(sortableElement, 'dragstart')\n  off(sortableElement, 'dragend')\n  off(sortableElement, 'drop')\n  // remove event data from sortable\n  removeSortableData(sortableElement)\n  // remove event handlers & data from items\n  off(handles, 'mousedown')\n  removeItemEvents(items)\n  removeItemData(items)\n  removeContainerEvents(originContainer, previousContainer)\n  // clear sortable flag\n  sortableElement.isSortable = false\n}\n/**\n * Enable the sortable\n * @param {HTMLElement} sortableElement a single sortable\n */\nconst enableSortable = function (sortableElement) {\n  const opts = data(sortableElement, 'opts')\n  const items = filter(sortableElement.children, opts.items)\n  const handles = getHandles(items, opts.handle)\n  attr(sortableElement, 'aria-dropeffect', 'move')\n  data(sortableElement, '_disabled', 'false')\n  attr(handles, 'draggable', 'true')\n  // enable hover class\n  enableHoverClass(sortableElement, true)\n  // @todo: remove this fix\n  // IE FIX for ghost\n  // can be disabled as it has the side effect that other events\n  // (e.g. click) will be ignored\n  if (opts.disableIEFix === false) {\n    const spanEl = (document || window.document).createElement('span')\n    if (typeof spanEl.dragDrop === 'function') {\n      on(handles, 'mousedown', function () {\n        if (items.indexOf(this) !== -1) {\n          this.dragDrop()\n        } else {\n          let parent = this.parentElement\n          while (items.indexOf(parent) === -1) {\n            parent = parent.parentElement\n          }\n          parent.dragDrop()\n        }\n      })\n    }\n  }\n}\n/**\n * Disable the sortable\n * @param {HTMLElement} sortableElement a single sortable\n */\nconst disableSortable = function (sortableElement) {\n  const opts = data(sortableElement, 'opts')\n  const items = filter(sortableElement.children, opts.items)\n  const handles = getHandles(items, opts.handle)\n  attr(sortableElement, 'aria-dropeffect', 'none')\n  data(sortableElement, '_disabled', 'true')\n  attr(handles, 'draggable', 'false')\n  off(handles, 'mousedown')\n  enableHoverClass(sortableElement, false)\n}\n/**\n * Reload the sortable\n * @param {HTMLElement} sortableElement a single sortable\n * @description events need to be removed to not be double bound\n */\nconst reloadSortable = function (sortableElement) {\n  const opts = data(sortableElement, 'opts')\n  const items = filter(sortableElement.children, opts.items)\n  const handles = getHandles(items, opts.handle)\n  data(sortableElement, '_disabled', 'false')\n  // remove event handlers from items\n  removeItemEvents(items)\n  removeContainerEvents(originContainer, previousContainer)\n  off(handles, 'mousedown')\n  // remove event handlers from sortable\n  off(sortableElement, 'dragover')\n  off(sortableElement, 'dragenter')\n  off(sortableElement, 'drop')\n}\n\n/**\n * Public sortable object\n * @param {Array|NodeList} sortableElements\n * @param {object|string} options|method\n */\nexport default function sortable (sortableElements, options: configuration|object|string|undefined): sortable {\n  // get method string to see if a method is called\n  const method = String(options)\n  options = options || {}\n  // check if the user provided a selector instead of an element\n  if (typeof sortableElements === 'string') {\n    sortableElements = document.querySelectorAll(sortableElements)\n  }\n  // if the user provided an element, return it in an array to keep the return value consistant\n  if (sortableElements instanceof HTMLElement) {\n    sortableElements = [sortableElements]\n  }\n\n  sortableElements = Array.prototype.slice.call(sortableElements)\n\n  if (/serialize/.test(method)) {\n    return sortableElements.map((sortableContainer) => {\n      const opts = data(sortableContainer, 'opts')\n      return serialize(sortableContainer, opts.itemSerializer, opts.containerSerializer)\n    })\n  }\n\n  sortableElements.forEach(function (sortableElement) {\n    if (/enable|disable|destroy/.test(method)) {\n      return sortable[method](sortableElement)\n    }\n    // log deprecation\n    ['connectWith', 'disableIEFix'].forEach((configKey) => {\n      if (Object.prototype.hasOwnProperty.call(options, configKey) && options[configKey] !== null) {\n        console.warn(`HTML5Sortable: You are using the deprecated configuration \"${configKey}\". This will be removed in an upcoming version, make sure to migrate to the new options when updating.`)\n      }\n    })\n    // merge options with default options\n    options = Object.assign({}, defaultConfiguration, store(sortableElement).config, options)\n    // init data store for sortable\n    store(sortableElement).config = options\n    // set options on sortable\n    data(sortableElement, 'opts', options)\n    // property to define as sortable\n    sortableElement.isSortable = true\n    // reset sortable\n    reloadSortable(sortableElement)\n    // initialize\n    const listItems = filter(sortableElement.children, options.items)\n    // create element if user defined a placeholder element as a string\n    let customPlaceholder\n    if (options.placeholder !== null && options.placeholder !== undefined) {\n      const tempContainer = document.createElement(sortableElement.tagName)\n      if (options.placeholder instanceof HTMLElement) {\n        tempContainer.appendChild(options.placeholder)\n      } else {\n        tempContainer.innerHTML = options.placeholder\n      }\n      customPlaceholder = tempContainer.children[0]\n    }\n    // add placeholder\n    store(sortableElement).placeholder = makePlaceholder(sortableElement, customPlaceholder, options.placeholderClass)\n\n    data(sortableElement, 'items', options.items)\n\n    if (options.acceptFrom) {\n      data(sortableElement, 'acceptFrom', options.acceptFrom)\n    } else if (options.connectWith) {\n      data(sortableElement, 'connectWith', options.connectWith)\n    }\n\n    enableSortable(sortableElement)\n    attr(listItems, 'role', 'option')\n    attr(listItems, 'aria-grabbed', 'false')\n    /*\n     Handle drag events on draggable items\n     Handle is set at the sortableElement level as it will bubble up\n     from the item\n     */\n    on(sortableElement, 'dragstart', function (e) {\n      // ignore dragstart events\n      const target = getEventTarget(e)\n      if (target.isSortable === true) {\n        return\n      }\n      e.stopImmediatePropagation()\n\n      if ((options.handle && !target.matches(options.handle)) || target.getAttribute('draggable') === 'false') {\n        return\n      }\n\n      const sortableContainer = findSortable(target, e)\n      const dragItem = findDragElement(sortableContainer, target)\n\n      // grab values\n      originItemsBeforeUpdate = filter(sortableContainer.children, options.items)\n      originIndex = originItemsBeforeUpdate.indexOf(dragItem)\n      originElementIndex = getIndex(dragItem, sortableContainer.children)\n      originContainer = sortableContainer\n\n      // add transparent clone or other ghost to cursor\n      setDragImage(e, dragItem, options.customDragImage)\n      // cache selsection & add attr for dragging\n      draggingHeight = getElementHeight(dragItem)\n      draggingWidth = getElementWidth(dragItem)\n      dragItem.classList.add(options.draggingClass)\n      dragging = getDragging(dragItem, sortableContainer)\n      attr(dragging, 'aria-grabbed', 'true')\n\n      // dispatch sortstart event on each element in group\n      sortableContainer.dispatchEvent(new CustomEvent('sortstart', {\n        detail: {\n          origin: {\n            elementIndex: originElementIndex,\n            index: originIndex,\n            container: originContainer\n          },\n          item: dragging,\n          originalTarget: target\n        }\n      }))\n    })\n\n    /*\n     We are capturing targetSortable before modifications with 'dragenter' event\n    */\n    on(sortableElement, 'dragenter', (e) => {\n      const target = getEventTarget(e)\n      const sortableContainer = findSortable(target, e)\n\n      if (sortableContainer && sortableContainer !== previousContainer) {\n        destinationItemsBeforeUpdate = filter(sortableContainer.children, data(sortableContainer, 'items'))\n          .filter(item => item !== store(sortableElement).placeholder)\n\n        if (options.dropTargetContainerClass) {\n          sortableContainer.classList.add(options.dropTargetContainerClass)\n        }\n        sortableContainer.dispatchEvent(new CustomEvent('sortenter', {\n          detail: {\n            origin: {\n              elementIndex: originElementIndex,\n              index: originIndex,\n              container: originContainer\n            },\n            destination: {\n              container: sortableContainer,\n              itemsBeforeUpdate: destinationItemsBeforeUpdate\n            },\n            item: dragging,\n            originalTarget: target\n          }\n        }))\n\n        on(sortableContainer, 'dragleave', e => {\n          // TODO: rename outTarget to be more self-explanatory\n          // e.fromElement for very old browsers, similar to relatedTarget\n          const outTarget = e.relatedTarget || e.fromElement\n          if (!e.currentTarget.contains(outTarget)) {\n            if (options.dropTargetContainerClass) {\n              sortableContainer.classList.remove(options.dropTargetContainerClass)\n            }\n            sortableContainer.dispatchEvent(new CustomEvent('sortleave', {\n              detail: {\n                origin: {\n                  elementIndex: originElementIndex,\n                  index: originIndex,\n                  container: sortableContainer\n                },\n                item: dragging,\n                originalTarget: target\n              }\n            }))\n          }\n        })\n      }\n      previousContainer = sortableContainer\n    })\n\n    /*\n     * Dragend Event - https://developer.mozilla.org/en-US/docs/Web/Events/dragend\n     * Fires each time dragEvent end, or ESC pressed\n     * We are using it to clean up any draggable elements and placeholders\n     */\n    on(sortableElement, 'dragend', function (e) {\n      if (!dragging) {\n        return\n      }\n\n      dragging.classList.remove(options.draggingClass)\n      attr(dragging, 'aria-grabbed', 'false')\n\n      if (dragging.getAttribute('aria-copied') === 'true' && data(dragging, 'dropped') !== 'true') {\n        dragging.remove()\n      }\n      if (dragging.oldDisplay !== undefined) {\n        dragging.style.display = dragging.oldDisplay\n        delete dragging.oldDisplay\n      }\n      const visiblePlaceholder = Array.from(stores.values()).map(data => data.placeholder)\n        .filter(placeholder => placeholder instanceof HTMLElement)\n        .filter(isInDom)[0]\n\n      if (visiblePlaceholder) {\n        visiblePlaceholder.remove()\n      }\n\n      // dispatch sortstart event on each element in group\n      sortableElement.dispatchEvent(new CustomEvent('sortstop', {\n        detail: {\n          origin: {\n            elementIndex: originElementIndex,\n            index: originIndex,\n            container: originContainer\n          },\n          item: dragging\n        }\n      }))\n\n      previousContainer = null\n      dragging = null\n      draggingHeight = null\n      draggingWidth = null\n    })\n\n    /*\n     * Drop Event - https://developer.mozilla.org/en-US/docs/Web/Events/drop\n     * Fires when valid drop target area is hit\n     */\n    on(sortableElement, 'drop', function (e) {\n      if (!listsConnected(sortableElement, dragging.parentElement)) {\n        return\n      }\n      e.preventDefault()\n      e.stopPropagation()\n\n      data(dragging, 'dropped', 'true')\n      // get the one placeholder that is currently visible\n      const visiblePlaceholder = Array.from(stores.values()).map((data) => {\n        return data.placeholder\n      })\n        // filter only HTMLElements\n        .filter(placeholder => placeholder instanceof HTMLElement)\n        // only elements in DOM\n        .filter(isInDom)[0]\n      if (visiblePlaceholder) {\n        visiblePlaceholder.replaceWith(dragging)\n        // to avoid flickering restoring element display immediately after replacing placeholder\n        if (dragging.oldDisplay !== undefined) {\n          dragging.style.display = dragging.oldDisplay\n          delete dragging.oldDisplay\n        }\n        // We need to reset placeholder if any css class were added.\n        options.keepCssClass.forEach(className => {\n          store(sortableElement).placeholder.classList.remove(className)\n        });\n      } else {\n        // set the dropped value to 'false' to delete copied dragging at the time of 'dragend'\n        data(dragging, 'dropped', 'false')\n        return\n      }\n      /*\n       * Fires Custom Event - 'sortstop'\n       */\n      sortableElement.dispatchEvent(new CustomEvent('sortstop', {\n        detail: {\n          origin: {\n            elementIndex: originElementIndex,\n            index: originIndex,\n            container: originContainer\n          },\n          item: dragging\n        }\n      }))\n\n      const placeholder = store(sortableElement).placeholder\n      const originItems = filter(originContainer.children, options.items)\n        .filter(item => item !== placeholder)\n      const destinationContainer = this.isSortable === true ? this : this.parentElement\n      const destinationItems = filter(destinationContainer.children, data(destinationContainer, 'items'))\n        .filter(item => item !== placeholder)\n      const destinationElementIndex = getIndex(dragging, Array.from(dragging.parentElement.children)\n        .filter(item => item !== placeholder))\n      const destinationIndex = getIndex(dragging, destinationItems)\n\n      if (options.dropTargetContainerClass) {\n        destinationContainer.classList.remove(options.dropTargetContainerClass)\n      }\n\n      /*\n       * When a list item changed container lists or index within a list\n       * Fires Custom Event - 'sortupdate'\n       */\n      if (originElementIndex !== destinationElementIndex || originContainer !== destinationContainer) {\n        sortableElement.dispatchEvent(new CustomEvent('sortupdate', {\n          detail: {\n            origin: {\n              elementIndex: originElementIndex,\n              index: originIndex,\n              container: originContainer,\n              itemsBeforeUpdate: originItemsBeforeUpdate,\n              items: originItems\n            },\n            destination: {\n              index: destinationIndex,\n              elementIndex: destinationElementIndex,\n              container: destinationContainer,\n              itemsBeforeUpdate: destinationItemsBeforeUpdate,\n              items: destinationItems\n            },\n            item: dragging\n          }\n        }))\n      }\n    })\n\n    const debouncedDragOverEnter = debounce((sortableElement, element, pageX, pageY) => {\n      if (!dragging) {\n        return\n      }\n\n      // set placeholder height if forcePlaceholderSize option is set\n      if (options.forcePlaceholderSize) {\n        store(sortableElement).placeholder.style.height = draggingHeight + 'px'\n        store(sortableElement).placeholder.style.width = draggingWidth + 'px'\n      }\n      // Keep some CSS class fo the dragged element, to keep style.\n      // Usefull if sortable elements have different dimensions according class.\n      options.keepCssClass.forEach(className => {\n        if (element.classList.contains(className)) {\n          store(sortableElement).placeholder.classList.add(className)\n        }\n      });\n      // if element the draggedItem is dragged onto is within the array of all elements in list\n      // (not only items, but also disabled, etc.)\n      if (Array.from(sortableElement.children).indexOf(element) > -1) {\n        const thisHeight = getElementHeight(element)\n        const thisWidth = getElementWidth(element)\n        const placeholderIndex = getIndex(store(sortableElement).placeholder, element.parentElement.children)\n        const thisIndex = getIndex(element, element.parentElement.children)\n        // Check if `element` is bigger than the draggable. If it is, we have to define a dead zone to prevent flickering\n        if (thisHeight > draggingHeight || thisWidth > draggingWidth) {\n          // Dead zone?\n          const deadZoneVertical = thisHeight - draggingHeight\n          const deadZoneHorizontal = thisWidth - draggingWidth\n          const offsetTop = offset(element).top\n          const offsetLeft = offset(element).left\n          if (placeholderIndex < thisIndex &&\n              ((options.orientation === 'vertical' && pageY < offsetTop) ||\n                  (options.orientation === 'horizontal' && pageX < offsetLeft))) {\n            return\n          }\n          if (placeholderIndex > thisIndex &&\n              ((options.orientation === 'vertical' && pageY > offsetTop + thisHeight - deadZoneVertical) ||\n                  (options.orientation === 'horizontal' && pageX > offsetLeft + thisWidth - deadZoneHorizontal))) {\n            return\n          }\n        }\n\n        if (dragging.oldDisplay === undefined) {\n          dragging.oldDisplay = dragging.style.display\n        }\n\n        if (dragging.style.display !== 'none') {\n          dragging.style.display = 'none'\n        }\n        // To avoid flicker, determine where to position the placeholder\n        // based on where the mouse pointer is relative to the elements\n        // vertical center.\n        let placeAfter = false\n        try {\n          const elementMiddleVertical = offset(element).top + element.offsetHeight / 2\n          const elementMiddleHorizontal = offset(element).left + element.offsetWidth / 2\n          placeAfter = (options.orientation === 'vertical' && (pageY >= elementMiddleVertical)) ||\n              (options.orientation === 'horizontal' && (pageX >= elementMiddleHorizontal))\n        } catch (e) {\n          placeAfter = placeholderIndex < thisIndex\n        }\n\n        if (placeAfter) {\n          after(element, store(sortableElement).placeholder)\n        } else {\n          before(element, store(sortableElement).placeholder)\n        }\n        // get placeholders from all stores & remove all but current one\n        Array.from(stores.values())\n          // remove empty values\n          .filter(data => data.placeholder !== undefined)\n          // foreach placeholder in array if outside of current sorableContainer -> remove from DOM\n          .forEach((data) => {\n            if (data.placeholder !== store(sortableElement).placeholder) {\n              data.placeholder.remove()\n            }\n          })\n      } else {\n        // get all placeholders from store\n        const placeholders = Array.from(stores.values())\n          .filter((data) => data.placeholder !== undefined)\n          .map((data) => {\n            return data.placeholder\n          })\n        // check if element is not in placeholders\n        if (placeholders.indexOf(element) === -1 && sortableElement === element && !filter(element.children, options.items).length) {\n          placeholders.forEach((element) => element.remove())\n          element.appendChild(store(sortableElement).placeholder)\n        }\n      }\n    }, options.debounce)\n    // Handle dragover and dragenter events on draggable items\n    const onDragOverEnter = function (e) {\n      let element = e.target\n      const sortableElement = element.isSortable === true ? element : findSortable(element, e)\n      element = findDragElement(sortableElement, element)\n      if (!dragging || !listsConnected(sortableElement, dragging.parentElement) || data(sortableElement, '_disabled') === 'true') {\n        return\n      }\n      const options = data(sortableElement, 'opts')\n      if (parseInt(options.maxItems) && filter(sortableElement.children, data(sortableElement, 'items')).length > parseInt(options.maxItems) && dragging.parentElement !== sortableElement) {\n        return\n      }\n      e.preventDefault()\n      e.stopPropagation()\n      e.dataTransfer.dropEffect = store(sortableElement).getConfig('copy') === true ? 'copy' : 'move'\n      debouncedDragOverEnter(sortableElement, element, e.pageX, e.pageY)\n    }\n\n    on(listItems.concat(sortableElement), 'dragover', onDragOverEnter)\n    on(listItems.concat(sortableElement), 'dragenter', onDragOverEnter)\n  })\n\n  return sortableElements\n}\n\nsortable.destroy = function (sortableElement) {\n  destroySortable(sortableElement)\n}\n\nsortable.enable = function (sortableElement) {\n  enableSortable(sortableElement)\n}\n\nsortable.disable = function (sortableElement) {\n  disableSortable(sortableElement)\n}\n\n/* START.TESTS_ONLY */\nsortable.__testing = {\n  // add internal methods here for testing purposes\n  data: data,\n  removeItemEvents: removeItemEvents,\n  removeItemData: removeItemData,\n  removeSortableData: removeSortableData,\n  removeContainerEvents: removeContainerEvents\n}\n/* END.TESTS_ONLY */\n","/* eslint-env browser */\nimport store from './store'\nimport filter from './filter'\nimport throttle from './throttle'\nimport { addEventListener, removeEventListener } from './eventListener'\n/**\n * enable or disable hoverClass on mouseenter/leave if container Items\n * @param {sortable} sortableContainer a valid sortableContainer\n * @param {boolean} enable enable or disable event\n */\nexport default (sortableContainer: sortable, enable: boolean) => {\n  if (typeof store(sortableContainer).getConfig('hoverClass') === 'string') {\n    const hoverClasses = store(sortableContainer).getConfig('hoverClass').split(' ')\n    // add class on hover\n    if (enable === true) {\n      addEventListener(sortableContainer, 'mousemove', throttle((event) => {\n        // check of no mouse button was pressed when mousemove started == no drag\n        if (event.buttons === 0) {\n          filter(sortableContainer.children, store(sortableContainer).getConfig('items')).forEach(item => {\n            if (item === event.target || item.contains(event.target)) {\n              item.classList.add(...hoverClasses)\n            } else {\n              item.classList.remove(...hoverClasses)\n            }\n          })\n        }\n      }, store(sortableContainer).getConfig('throttleTime')))\n      // remove class on leave\n      addEventListener(sortableContainer, 'mouseleave', () => {\n        filter(sortableContainer.children, store(sortableContainer).getConfig('items')).forEach(item => {\n          item.classList.remove(...hoverClasses)\n        })\n      })\n    // remove events\n    } else {\n      removeEventListener(sortableContainer, 'mousemove')\n      removeEventListener(sortableContainer, 'mouseleave')\n    }\n  }\n}\n","/**\n * make sure a function is only called once within the given amount of time\n * @param {Function} fn the function to throttle\n * @param {number} threshold time limit for throttling\n */\n// must use function to keep this context\nexport default function (fn: Function, threshold: number = 250) {\n  // check function\n  if (typeof fn !== 'function') {\n    throw new Error('You must provide a function as the first argument for throttle.')\n  }\n  // check threshold\n  if (typeof threshold !== 'number') {\n    throw new Error('You must provide a number as the second argument for throttle.')\n  }\n\n  let lastEventTimestamp = null\n\n  return (...args) => {\n    const now = Date.now()\n    if (lastEventTimestamp === null || now - lastEventTimestamp >= threshold) {\n      lastEventTimestamp = now\n      fn.apply(this, args)\n    }\n  }\n}\n"],"names":["addData","element","key","value","undefined","h5s","data","nodes","selector","NodeList","HTMLCollection","Array","Error","from","filter","item","nodeType","matches","stores","Map","this","Object","Store","config","_config","forEach","mergedConfig","assign","entries","has","set","get","_placeholder","placeholder","HTMLElement","_data","delete","sortableElement","addEventListener","eventName","callback","i","length","store","setData","removeEventListener","getData","deleteData","addAttribute","attribute","setAttribute","removeAttribute","parentElement","getClientRects","rect","left","window","pageXOffset","right","top","pageYOffset","bottom","func","wait","timeout","_i","args","clearTimeout","setTimeout","elementList","indexOf","parentNode","insertNode","referenceNode","newElement","position","insertBefore","nextElementSibling","target","insertAfter","sortableContainer","customItemSerializer","customContainerSerializer","serializedItem","serializedContainer","isSortable","items","children","serializedItems","map","parent","node","html","outerHTML","index","getIndex","container","itemCount","placeholderClass","includes","tagName","document","createElement","innerHTML","_a","classList","add","split","style","getComputedStyle","getPropertyValue","parseInt","int","isNaN","reduce","sum","querySelector","shadowRoot","event","composedPath","defaultDragImage","draggedElement","elementOffset","posX","pageX","posY","pageY","customDragImage","Event","dataTransfer","setDragImage","dragImage","offset","effectAllowed","getEventTarget","id","destination","origin","acceptFrom","getConfig","sel","connectWith","disableIEFix","copy","draggingClass","hoverClass","dropTargetContainerClass","debounce","throttleTime","maxItems","itemSerializer","containerSerializer","orientation","dragging","draggingHeight","draggingWidth","originContainer","originIndex","originElementIndex","originItemsBeforeUpdate","previousContainer","destinationItemsBeforeUpdate","enable","hoverClasses_1","fn","threshold","lastEventTimestamp","now","Date","apply","_this","throttle","buttons","contains","_b","remove","removeItemEvents","off","removeContainerEvents","getDragging","draggedItem","sortable","ditem","attr","cloneNode","appendChild","display","oldDisplay","removeSortableData","removeAttr","removeItemData","findSortable","find","el","findDragElement","options","itemlist","ele","enableSortable","opts","handles","getHandles","handle","enableHoverClass","dragDrop","on","reloadSortable","sortableElements","method","String","querySelectorAll","prototype","slice","call","test","serialize","configKey","hasOwnProperty","console","warn","defaultConfiguration","customPlaceholder","listItems","tempContainer","makePlaceholder","e","stopImmediatePropagation","getAttribute","dragItem","getElementHeight","getElementWidth","dispatchEvent","CustomEvent","detail","elementIndex","originalTarget","itemsBeforeUpdate","outTarget","relatedTarget","fromElement","currentTarget","visiblePlaceholder","values","isInDom","listsConnected","preventDefault","stopPropagation","replaceWith","keepCssClass","className","originItems","destinationContainer","destinationItems","destinationElementIndex","destinationIndex","debouncedDragOverEnter","forcePlaceholderSize","height","width","thisHeight","thisWidth","placeholderIndex","thisIndex","deadZoneVertical","deadZoneHorizontal","offsetTop","offsetLeft","placeAfter","elementMiddleVertical","offsetHeight","elementMiddleHorizontal","offsetWidth","after","before","placeholders","onDragOverEnter","dropEffect","concat","destroy","disable","__testing"],"mappings":"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"}